#include <iostream>
#include <vector>
#include <ctime>
#include <algorithm>
using namespace std;

/**
 * @ Funcție recursivă pentru verificarea satisfiabilității folosind backtracking.
 * @param clauses: Lista de clauze care trebuie satisfăcute.
 * @param assignment: Vector care ține evidența asignării valorilor pentru variabile.
 * @param var_idx: Indexul variabilei curente în procesul de asignare.
 * @return True dacă satisfacția a fost găsită pentru toate clauzele, false altfel.
 */
bool dp_helper(vector<vector<int>>& clauses, vector<bool>& assignment, int var_idx) {
    // Verificăm satisfacția tuturor clauzelor
    if (var_idx == assignment.size()) {
        for (int i = 0; i < clauses.size(); ++i) {
            bool clause_satisfied = false;
            // Folosim un for clasic cu index pentru a parcurge fiecare literal al clauzei
            for (int j = 0; j < clauses[i].size(); ++j) {
                int lit = clauses[i][j];  // Accesăm elementul clauzei prin index
                // Verificăm fiecare literal al clauzei
                if (lit > 0 && assignment[lit - 1] || lit < 0 && !assignment[-lit - 1]) {
                    clause_satisfied = true;
                    break;
                }
            }
            if (!clause_satisfied) return false;
        }
        return true;
    }

  
    assignment[var_idx] = true;
    if (dp_helper(clauses, assignment, var_idx + 1)) return true;

  
    assignment[var_idx] = false;
    return dp_helper(clauses, assignment, var_idx + 1);
}

/**
 *  Algoritmul DP pentru verificarea satisfiabilității.
 * @param clauses: Lista de clauze care trebuie satisfăcute.
 * @param n: Numărul de variabile.
 * @return True dacă formularea este satisfiabilă, false altfel.
 */
bool dp(vector<vector<int>>& clauses, int n) {
    vector<bool> assignment(n, false); // Inițializare valori false pentru variabile
    return dp_helper(clauses, assignment, 0); // Apelăm funcția recursivă
}

/**
 *  Algoritmul DPLL pentru verificarea satisfiabilității.
 * @param clauses: Lista de clauze care trebuie satisfăcute.
 * @param assignment: Vector care ține evidența asignării valorilor pentru variabile.
 * @param var_idx: Indexul variabilei curente în procesul de asignare.
 * @return True dacă satisfacția a fost găsită pentru toate clauzele, false altfel.
 */
bool dpll(vector<vector<int>>& clauses, vector<bool>& assignment, int var_idx) {
    // Verificăm satisfacția tuturor clauzelor
    if (var_idx == assignment.size()) {
        for (int i = 0; i < clauses.size(); ++i) {
            bool satisfied = false;
            // Folosim un for clasic cu index pentru a parcurge fiecare literal al clauzei
            for (int j = 0; j < clauses[i].size(); ++j) {
                int lit = clauses[i][j];  // Accesăm elementul clauzei prin index
                if (lit > 0 && assignment[lit - 1] || lit < 0 && !assignment[-lit - 1]) {
                    satisfied = true;
                    break;
                }
            }
            if (!satisfied) return false;
        }
        return true;
    }

  â
    assignment[var_idx] = true;
    if (dpll(clauses, assignment, var_idx + 1)) return true;

    
    assignment[var_idx] = false;
    return dpll(clauses, assignment, var_idx + 1);
}

int main() {
    int m, n;
    cout << "Câte clauze doriți să introduceți? ";
    cin >> m;

    vector<vector<int>> clauses(m); 
    vector<int> vars; 
    
    for (int i = 0; i < m; ++i) {
        cout << "C" << i + 1 << ": Introduceți clauza (ex: 1 -2 3): ";
        int x;
        while (cin >> x) {
            clauses[i].push_back(x);
            if (cin.peek() == '\n') 
                 break;
        }
        // Adăugăm variabilele în lista de variabile,fără duplicate
        for (int j = 0; j < clauses[i].size(); ++j) {
            int val = clauses[i][j];
            if (find(vars.begin(), vars.end(), abs(val)) == vars.end()) {
                vars.push_back(abs(val));
            }
        }
    }

    n = vars.size(); 

    // Măsurăm timpul pentru algoritmul DP
    clock_t start_dp = clock();
    bool dp_result = dp(clauses, n);
    clock_t end_dp = clock();
    double time_dp = double(end_dp - start_dp) / CLOCKS_PER_SEC;

    // Măsurăm timpul pentru algoritmul DPLL
    clock_t start_dpll = clock();
    vector<bool> assignment(n, false);
    bool dpll_result = dpll(clauses, assignment, 0);
    clock_t end_dpll = clock();
    double time_dpll = double(end_dpll - start_dpll) / CLOCKS_PER_SEC;

   
    cout << "\nTimpul de executie DP: " << time_dp << " sec" << endl;
    cout << "Timpul de executie DPLL: " << time_dpll << " sec" << endl;
    
 
    cout << "Satisfiabilitate (DP): " << (dp_result ? "Satisfiabil" : "Nesatisfiabil") << endl;
    cout << "Satisfiabilitate (DPLL): " << (dpll_result ? "Satisfiabil" : "Nesatisfiabil") << endl;

    // Comparăm eficiența algoritmilor pe baza timpului de execuție
    if (time_dp < time_dpll) {
        cout << "Algoritmul mai eficient este DP.\n";
    } else {
        cout << "Algoritmul mai eficient este DPLL.\n";
    }

    return 0;
}

